<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\..\Runtime\Source\Runtime.Schema\DslDefinition.dsl'" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#
	// ******************************************************************************************
	// This template generates the code required for testing generated tracking properties in a DSL.
	// see the associated text template in the GeneratedCode folder in the DSL Project
	//
	// Notes to DSL Implementors:
	// In order to test a tracking property, you must do the following in addition to unit testing the tracked value.
	// In Test Code:
	//		Create  the Spec test class "public partial class MyTrackedPropertyDomainClass" for the DomainClass containing the tracked property.
	//		Define a context test class 
	//			Derive the class from the genreated test class "GivenAMyTrackedPropertyDomainClass"
	//			Implement the property "protected override MyTrackedPropertyDomainClass Element { get; private set; }"
	//			Implement unit test methods for checking that the tracked property value updates when 
	//				any of the properties that it calculates it values from are changed (see your implementation of the CalculateMyTrackedPropertyTrackingValue() method.
	//
	// ******************************************************************************************

	string dslName = this.DslLibrary.Name;

	// Find all domain properties that are named for tracking
	Dictionary<string, string[]> trackingClasses = new Dictionary<string, string[]>();
	foreach (var domainClass in this.DslLibrary.Classes)
	{
		List<string> trackedProperties = new List<string>();
		foreach (DomainProperty domainProperty in domainClass.Properties)
		{
            if ((domainProperty.Name.StartsWith("Is"))
                && (domainProperty.Name.EndsWith("Tracking")))
            {
                string trackedPropertyName = domainProperty.Name.Substring("Is".Length, (domainProperty.Name.Length - "Tracking".Length - 2));
				trackedProperties.Add(trackedPropertyName);
            }
		}

		if (trackedProperties.Count > 0)
		{
			trackingClasses.Add(domainClass.Name, trackedProperties.ToArray<string>());
		}
	}
#>
using Microsoft.VisualStudio.Patterning.Extensibility;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Microsoft.VisualStudio.Patterning.Runtime.Schema.UnitTests
{
<#
	foreach (KeyValuePair<string, string[]> trackingClass in trackingClasses)
	{
#>
    public partial class <#= trackingClass.Key #>Spec
    {
        private static readonly IAssertion Assert = new Assertion();

        [TestClass]
        public abstract class GivenA<#= trackingClass.Key #>
        {
            protected abstract <#= trackingClass.Key #> Element
            {
				get;
            }
<# 
			foreach (string propertyName in trackingClass.Value)
			{
#>

            [TestMethod, TestCategory("Unit")]
            public void Then<#=propertyName #>IsTracking()
            {
                Assert.True(this.Element.Is<#=propertyName #>Tracking);
                Assert.Equal(this.Element.Calculate<#=propertyName #>TrackingValue(), this.Element.<#=propertyName #>);
            }

            [TestMethod, TestCategory("Unit")]
            public void WhenTrackedPropertyIsChanged_Then<#=propertyName #>NotTracking()
            {
			    this.Element.Store.TransactionManager.DoWithinTransaction( () =>
                    {
                        this.Element.<#=propertyName #> = "Test<#=propertyName #>Changed";
                    });

                Assert.False(this.Element.Is<#=propertyName #>Tracking);
                Assert.Equal("Test<#=propertyName #>Changed", this.Element.<#=propertyName #>);
            }
<#
			}
#>
		}
	}

<#
	}
#>
}
