<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\Runtime.Store\DslDefinition.dsl'" #>
<#@ include file="Dsl\Utilities.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\DslVersion.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\Helpers.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\PropertyChangedInterface.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq.Expressions;

namespace NuPattern.Runtime
{<#
	PushIndent("\t"); 
	foreach (var domainClass in this.DslLibrary.Classes)
	{
		GenerateInterface(domainClass);
	}

	PopIndent();
#>
}
<#+
private void GenerateInterface(DomainClass domainClass)
{
	GeneratePropertyChanged(domainClass, domainClass.Name);

	var baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, string.Empty);
#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[Description("<#= domainClass.Description #>")]
[GeneratedCode("<#= this.ToolName #>", "<#= this.DslVersion #>")]
public partial interface I<#= domainClass.Name #> : <#= !string.IsNullOrEmpty(baseInterface) ? "I" + baseInterface : "ISupportTransaction" #> 
{<#+
	if (!IsRoot(domainClass) && !HasAnnotationFlag(domainClass.Notes, "SkipInfoProperty"))
	{
#>

	/// <summary>
	/// Provides read-only access to the schema information for this element.
	/// </summary>
	[Description("Provides read-only access to the schema information for this element.")]
	[ReadOnly(true)]
	[Hidden]
	<#= string.IsNullOrEmpty(baseInterface) ? string.Empty : "new " #>I<#= ToInfo(domainClass) #> Info { get; }
<#+
	}

	if (string.IsNullOrEmpty(baseInterface))
	{
#>

	/// <summary>
	/// Gets the identifier for this element.
	/// </summary>
	[Hidden]
	global::System.Guid Id { get; }
<#+
	}

	foreach (var property in domainClass.Properties)
	{
		GenerateProperty(property);
	}
	
	foreach(DomainRole role in domainClass.RolesPlayed)
	{
		GenerateProperty(role);
	}

	if (string.IsNullOrEmpty(baseInterface))
	{
#>

	/// <summary>
	/// Deletes an element from the store.
	/// </summary>
	void Delete();
<#+
	}
#>
}
<#+
}
private void GenerateProperty(DomainProperty property)
{
	if ((!PropertyHasGetter(property) && !PropertyHasSetter(property)) || 
		HasSkipAnnotation(property.Notes))
		return;

	PushIndent("\t");
#>

/// <summary>
/// <#= property.Description #>
/// </summary>
[Description("<#= property.Description #>")]
<#+
	GenerateClrAttributes(property.Attributes);

	if (property.IsUIReadOnly)
	{
		// UI readonly does not mean that we don't have API access, 
		// but rather that the setter is just not available via UI.
 #>
[ReadOnly(true)]
<#+
	} 
#>
<#= CodeGenerationUtilities.GetDomainTypeFullName(property) #> <#= property.Name #> { <#+ if(PropertyHasGetter(property)){ #>get;<#+ } if(PropertyHasSetter(property)) { #> set;<#+ } #> }
<#+
	PopIndent();
}

private bool PropertyHasSetter(DomainProperty property)
{
	if (property.Kind == PropertyKind.Calculated)
		return false;
	if (property.SetterAccessModifier != AccessModifier.Public)
		return false;

	return true;
}

private bool PropertyHasGetter(DomainProperty property)
{
	if (property.GetterAccessModifier != AccessModifier.Public)
		return false;

	return true;
}

private void GenerateProperty(DomainRole role)
{
	if (!role.IsPropertyGenerator)
		return;

	DomainRole opposite = role.Opposite;
	string castString = "";
	string propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	DomainRole typeRole = role;

	for (DomainRole current = role.BaseRole; current != null; current = current.BaseRole)
	{
		if (current != role && current.IsPropertyGenerator && current.PropertyName == role.PropertyName)
		{
			if ((current.Relationship.InheritanceModifier == InheritanceModifier.Abstract ||
				role.Relationship.InheritanceModifier == InheritanceModifier.Abstract) && 
				current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
			{
				break;
			}
			else 
			{
				typeRole = current;
			}
		}
	}

	if (typeRole != role)
	{
		castString = "(" + propertyType + ")";
		propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	}

	// Determine collection type for the property.
	string linkedElementCollectionType;
	if (typeRole.CollectionType != null)
	{
		// If a custom collection type was specified, use it.
		linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
	}
	else
	{
		switch (typeRole.Relationship.InheritanceModifier)
		{
			case InheritanceModifier.Abstract:
				linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
				break;
			case InheritanceModifier.None:
			case InheritanceModifier.Sealed:
				linkedElementCollectionType = "DslModeling::LinkedElementCollection";
				break;
			default:
				throw new NotSupportedException();
		}
	}
	PushIndent("\t");

	if (!HasSkipAnnotation(role.Notes))
	{
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
[Description("<#= role.Description #>")]
<#+
		GenerateClrAttributes(role.Attributes);

		if (role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || 
			role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
		{
#>
I<#= propertyType #> <#= role.PropertyName #> { get; set; }
<#+
		}
		else
		{
#>
IEnumerable<I<#= propertyType #>> <#= role.PropertyName #> { get; }
<#+
		}
	}

	if (!HasAnnotationFlag(role.Notes, "SkipCreate"))
		GenerateCreate(opposite, propertyType);

	PopIndent();
}

private void GenerateCreate(DomainRole role, string propertyType)
{
	// Generate Create factory methods.
	if (role.IsEmbedded)
	{
		if (role.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
		{
			GenerateCreate(propertyType, role.Opposite.PropertyName);
		}

		foreach (var derived in role.RolePlayer.AllDescendants.Where(dc => dc.InheritanceModifier != InheritanceModifier.Abstract))
		{
			var derivedType = derived.GetRelativeName(derived.Namespace, true);
			GenerateCreate(derivedType, role.Opposite.PropertyName);
		}
	}
}

private void GenerateCreate(string propertyType, string propertyName)
{
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#= propertyType #>"/> with an optional initializer to perform 
/// object initialization within the creation transaction. The child is automatically added to the 
///	<see cref="<#= propertyName #>"/> property.
/// </summary>
I<#= propertyType #> Create<#= propertyType #>(Action<I<#= propertyType #>> initializer = null);
<#+
}
#>