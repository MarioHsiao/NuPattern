<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\DslDefinition.dsl'" #>
<#@ Include File="..\..\..\..\..\Common\Helpers\DslVersion.tt" #>
<#@ Include File="..\..\..\..\..\Common\Helpers\Helpers.tt" #>
<#@ Include File="..\..\..\..\..\Common\Helpers\PropertyChangedImplementation.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using Microsoft.VisualStudio.TeamArchitect.PowerTools;
using NuPattern.ComponentModel;

<#
foreach (var domainClass in this.DslLibrary.Classes)
{
    GenerateClass(domainClass);
}
#>
<#+
private void GenerateClass(DomainClass domainClass)
{
#>
namespace <#= domainClass.Namespace #>
{ <#+
PushIndent("\t"); 

GeneratePropertyChanged(domainClass);

var baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, string.Empty);
#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[GeneratedCode("<#= this.ToolName #>", "<#= this.DslVersion #>")]
partial class <#= domainClass.Name #> : I<#= domainClass.Name #>
{ <#+
    if (!IsRoot(domainClass) && !HasAnnotationFlag(domainClass.Notes, "SkipInfoProperty"))
    {
        if (string.IsNullOrEmpty(baseInterface))
        {
#>

    /// <summary>
    /// Provides read-only access to the schema information for this element.
    /// </summary>
    public I<#= ToInfo(domainClass) #> Info { get; internal set; }
<#+
        }
        else
        {
#>

    /// <summary>
    /// Provides read-only access to the schema information for this element.
    /// </summary>
    public new I<#= ToInfo(domainClass) #> Info
    { 
        get { return (I<#= ToInfo(domainClass) #>)base.Info; }
        internal set { base.Info = value; }
    }
<#+
        }
    }

    foreach (var role in domainClass.RolesPlayed)
    {
        GenerateProperty(domainClass, role);
    }

    if (string.IsNullOrEmpty(baseInterface))
    {
#>

    /// <summary>
    /// Deletes an element from the store.
    /// </summary>
    void I<#= domainClass.Name #>.Delete()
    {
        if (this.Store.TransactionManager.InTransaction)
        {
            this.Delete();
        }
        else
        {
            using (var tx = this.Store.TransactionManager.BeginTransaction())
            {
                this.Delete();
                tx.Commit();
            }
        }
    }
<#+		
    }
#>
}
<#+	PopIndent(); #>
}
<#+
}
private void GenerateProperty(DomainProperty property)
{
    PushIndent("\t");
#>

/// <summary>
/// <#= property.Description #>
/// </summary>
<#= CodeGenerationUtilities.GetDomainTypeFullName(property) #> <#= property.Name #> { get; set; }
<#+
    PopIndent();
}

private void GenerateProperty(DomainClass domainClass, DomainRole role)
{
    if (!role.IsPropertyGenerator)
    {
        return;
    }

    var opposite = role.Opposite;
    var castString = string.Empty;
    var propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
    var typeRole = role;
    for (var current = role.BaseRole; current != null; current = current.BaseRole)
    {
        if (current!= role && current.IsPropertyGenerator && current.PropertyName==role.PropertyName)
        {
            if ((current.Relationship.InheritanceModifier==InheritanceModifier.Abstract || role.Relationship.InheritanceModifier==InheritanceModifier.Abstract) &&
                current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
            {
                break;
            }
            else 
            {
                typeRole = current;
            }
        }
    }

    if (typeRole != role)
    {
        castString = "(" + propertyType + ")";
        propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
    }

    // Determine collection type for the property.
    string linkedElementCollectionType;
    if (typeRole.CollectionType!=null)
    {
        // If a custom collection type was specified, use it.
        linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
    }
    else
    {
        switch (typeRole.Relationship.InheritanceModifier)
        {
            case InheritanceModifier.Abstract:
                linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
                break;
            case InheritanceModifier.None:
            case InheritanceModifier.Sealed:
                linkedElementCollectionType = "DslModeling::LinkedElementCollection";
                break;
            default:
                throw new NotSupportedException();
        }
    }

    PushIndent("\t");

    if (!HasSkipAnnotation(role.Notes))
    {
        if (role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
        {
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
I<#= propertyType #> I<#= domainClass.Name #>.<#= role.PropertyName #>
{
    get { return this.<#= role.PropertyName #>; }
    set { this.<#= role.PropertyName #> = (<#= propertyType #>)value; }
}
<#+
        }
        else
        {
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
IEnumerable<I<#= propertyType #>> I<#= domainClass.Name #>.<#= role.PropertyName #>
{
    get { return this.<#= role.PropertyName #>.Cast<I<#= propertyType #>>(); }
}

<#+
        }
    }

    if (!HasAnnotationFlag(role.Notes, "SkipCreate"))
        GenerateCreate(opposite, propertyType);

    PopIndent();
}

private void GenerateCreate(DomainRole role, string propertyType)
{
    // Generate Create factory methods.
    if (role.IsEmbedded)
    {
        if (role.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
        {
            GenerateCreate(propertyType, role.PropertyName);
        }

        foreach (var derived in role.RolePlayer.AllDescendants.Where(dc => dc.InheritanceModifier != InheritanceModifier.Abstract))
        {
            var derivedType = derived.GetRelativeName(derived.Namespace, true);
            GenerateCreate(derivedType, role.PropertyName);
        }
    }
}

private void GenerateCreate(string propertyType, string propertyName)
{
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#= propertyType #>"/> with an optional initializer to perform 
/// object initialization within the creation transaction.
/// </summary>
public I<#= propertyType #> Create<#= propertyType #>(Action<I<#= propertyType #>> initializer = null)
{
    using (var tx = this.Store.TransactionManager.BeginTransaction("InnerTx", this.IsSerializing))
    using (new StorePropertyBag(this.Store, ProductState.IsCreatingElementKey, true))
    {
        var instance = this.Create<<#= propertyType #>>();
        instance.<#= propertyName #> = this;
        if (initializer != null)
        {
            initializer(instance);
        }

        tx.Commit();
        return instance;
    }
}
<#+
}
#>