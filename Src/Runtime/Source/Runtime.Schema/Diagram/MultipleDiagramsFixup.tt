<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Drawing" #>
<#@ import namespace="System.Drawing.Drawing2D" #>
<#@ assembly name="System.Drawing.dll" #>
<#@ include file="Dsl\PathMerge.tt" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\DslDefinition.dsl'" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
using DslModeling = global::Microsoft.VisualStudio.Modeling;

namespace <#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>
{
<#
		Diagram diagram = this.Dsl.Diagram;
		
		// keep a list of classes in the shape maps, so we can detect the case
		// where a single class is mapped to multiple shapes.  Users will need
		// to write custom code for this case, to choose between the shapes.
		List<DomainClass> mappedClasses = new List<DomainClass>();
		// tables so we can easily look up from sorted list of classes back to the corresponding map.
		Dictionary<DomainClass, List<BaseShapeMap>> shapeMaps = new Dictionary<DomainClass, List<BaseShapeMap>>();
		Dictionary<DomainClass, List<ConnectorMap>> connectorMaps = new Dictionary<DomainClass, List<ConnectorMap>>();
		
		// List of decorator maps organized by decorator.
		Dictionary<Decorator, List<DecoratorMap>> decoratorMaps = new Dictionary<Decorator, List<DecoratorMap>>();	
		// List of shapes with mapped decorators
		List<DiagramElement> mappedDiagramElements = new List<DiagramElement>();
		
		foreach(BaseShapeMap baseMap in diagram.ShapeMaps)
		{
			DomainClass mappedDomainClass = baseMap.Class;
			List<BaseShapeMap> mapList;
			if(!shapeMaps.TryGetValue(mappedDomainClass, out mapList))
			{
				mappedClasses.Add(mappedDomainClass);
				mapList = new List<BaseShapeMap>();
				shapeMaps[mappedDomainClass] = mapList;
			}
			mapList.Add(baseMap);
			
			foreach(DecoratorMap decoratorMap in baseMap.DecoratorMaps)
			{
				List<DecoratorMap> decoratorMapList;
				if(!decoratorMaps.ContainsKey(decoratorMap.Decorator))
				{
					decoratorMapList = new List<DecoratorMap>();
					decoratorMaps[decoratorMap.Decorator] = decoratorMapList;
				}
				else
				{
					decoratorMapList = decoratorMaps[decoratorMap.Decorator];
				}
				
				decoratorMapList.Add(decoratorMap);
				DiagramElement mappedShape = decoratorMap.Decorator.DiagramElement;
				if(!mappedDiagramElements.Contains(mappedShape))
				{
					mappedDiagramElements.Add(mappedShape);
				}
			}
		}
		
		foreach(ConnectorMap connectorMap in diagram.ConnectorMaps)
		{
			DomainClass mappedDomainRelationship = connectorMap.Relationship;
			List<ConnectorMap> mapList;
			if(!connectorMaps.TryGetValue(mappedDomainRelationship, out mapList))
			{
				mappedClasses.Add(mappedDomainRelationship);
				mapList = new List<ConnectorMap>();
				connectorMaps[mappedDomainRelationship] = mapList;
			}
			mapList.Add(connectorMap);
			
			foreach(DecoratorMap decoratorMap in connectorMap.DecoratorMaps)
			{
				List<DecoratorMap> decoratorMapList;
				if(!decoratorMaps.ContainsKey(decoratorMap.Decorator))
				{
					decoratorMapList = new List<DecoratorMap>();
					decoratorMaps[decoratorMap.Decorator] = decoratorMapList;
				}
				else
				{
					decoratorMapList = decoratorMaps[decoratorMap.Decorator];
				}
				
				decoratorMapList.Add(decoratorMap);
				Connector mappedConnector = ConnectorHasDecorators.GetConnector(decoratorMap.Decorator);
				if(!mappedDiagramElements.Contains(mappedConnector))
				{
					mappedDiagramElements.Add(mappedConnector);
				}
			}
		}
		
		// sort the domain classes based on inheritance, so we check leaves first.
		mappedClasses.Sort(new DomainClassInheritanceComparer());
		
		object context = null;
		if(mappedClasses.Count > 0)
		{
			context = new object[] { mappedClasses, mappedDiagramElements, shapeMaps, connectorMaps, decoratorMaps };
		}
		// The Diagram class is likely to be referencing a lot of classes by its pivotal nature in the design so suppress class coupling warning

		if(mappedClasses.Count > 0)
		{
#>
	/// <summary>
	/// Rule that initiates view fixup when an element that has an associated shape is added to the model. 
	/// </summary>
<#
			foreach(DomainClass mappedDomainClass in mappedClasses)
			{
				// establish correct rule priorities for mapped shapes.  Swimlanes need to be created first, then
				// regular shapes, then ports.  This is so that parent shapes are created before child shapes.
				string shapeRulePriority = "DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority";
				List<BaseShapeMap> shapeMapList;
				if(shapeMaps.TryGetValue(mappedDomainClass, out shapeMapList))
				{
					foreach(BaseShapeMap baseMap in shapeMapList)
					{
						BaseShape baseShape = baseMap.BaseShape;
						if(baseShape != null)
						{
							if(baseShape is SwimLane)
							{
								shapeRulePriority = "DslDiagrams::DiagramFixupConstants.AddShapeRulePriority";
								break;
							}
							else if(baseShape is Port)
							{
								shapeRulePriority = "DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority + 1";
								break;
							}
						}
						
					}
				}
#>
	[DslModeling::RuleOn(typeof(<#= mappedDomainClass.GetFullName(true) #>), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = <#= mappedDomainClass is DomainRelationship ? "DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority" : shapeRulePriority #>, InitiallyDisabled=true)]
<#
			}
#>
	internal sealed partial class FixUpMultipleDiagram : FixUpDiagramBase
	{
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		public override void ElementAdded(DslModeling::ElementAddedEventArgs e)
		{
			if(e == null) throw new global::System.ArgumentNullException("e");
		
			DslModeling::ModelElement childElement = e.ModelElement;
			if (this.SkipFixup(childElement))
				return;
			DslModeling::ModelElement parentElement;
<#
			bool hasNonCustomConnector = false;
			if(connectorMaps.Count > 0)
			{
				// Check for custom flags specified for a particular connector map.
				// If no flags are specified, the generic GetParentForRelationship method is used (parent paths are ignored).
				foreach(DomainClass mappedDomainClass in mappedClasses)
				{
					List<ConnectorMap> mapList;
					
					if(connectorMaps.TryGetValue(mappedDomainClass, out mapList))
					{
						foreach(ConnectorMap connectorMap in mapList)
						{
							// If connecting to custom source/target shapes, there's no way to tell what the parent should be, so generate a custom code callout to get it.
							if(connectorMap.ConnectsCustomSource || connectorMap.ConnectsCustomTarget)
							{
#>
			if(childElement is <#= mappedDomainClass.GetFullName(true) #>)
			{
				// Method:
				// private Microsoft.VisualStudio.Modeling.ModelElement GetParentFor<#= mappedDomainClass.Name.Replace('@','_') #>(<#= mappedDomainClass.Name #> childLink)
				// {
				// }
				// must be implemented in a partial class of <#= diagram.Namespace #>.FixUpDiagram.  Given a child element link,
				// this method should return the parent model element that is associated with the shape or diagram that will be the parent 
				// of the connector created for this child.  If no connector should be created, the method should return null.
				parentElement = GetParentFor<#= mappedDomainClass.Name.Replace('@','_') #>((<#= mappedDomainClass.GetFullName(true) #>)childElement);
			} else
<#
								break;
							}
							else
							{
								hasNonCustomConnector = true;
							}
						}
					}
				}
				if(hasNonCustomConnector)
				{
#>
			if(childElement is DslModeling::ElementLink)
			{
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::Diagram> diagrams =
					childElement.Store.ElementDirectory.FindElements<DslDiagrams::Diagram>();

				for (int i = 0; i < diagrams.Count; i++)
				{
					parentElement = GetParentForRelationship(diagrams[i], (DslModeling::ElementLink)childElement);

					if (parentElement != null)
					{
						DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
					}
				}

				return;
			} else
<#
				}
			}
			foreach(DomainClass mappedDomainClass in mappedClasses)
			{
				List<BaseShapeMap> mapList;
				
				if(shapeMaps.TryGetValue(mappedDomainClass, out mapList))
				{
					bool customParent = false;
					bool hasParentElementPath = false;
					foreach(BaseShapeMap baseMap in mapList)
					{
						if(baseMap.HasCustomParentElement)
						{
							customParent = true;
							break;
						}
						else if(baseMap.ParentElementPath != null)
						{
							hasParentElementPath = true;
						}
					}
					
					// no parent path or custom path specified, nothing to do (this may be a derived map).
					if(!customParent && !hasParentElementPath)
					{
						continue;
					}
#>
			if(childElement is <#= mappedDomainClass.GetFullName(true) #>)
			{
<#
					if(customParent)
					{
#>
				// Method:
				// private Microsoft.VisualStudio.Modeling.ModelElement GetParentFor<#= mappedDomainClass.Name.Replace('@','_') #>(<#= mappedDomainClass.Name #> childElement)
				// {
				// }
				// must be implemented in a partial class of <#= diagram.Namespace #>.FixUpDiagram.  Given a child element,
				// this method should return the parent model element that is associated with the shape or diagram that will be the parent 
				// of the shape created for this child.  If no shape should be created, the method should return null.
<#
					}
#>
				parentElement = GetParentFor<#= mappedDomainClass.Name.Replace('@','_') #>((<#= mappedDomainClass.GetFullName(true) #>)childElement);
			} else
<#
				}
			}
#>
			{
				parentElement = null;
			}
			
			if(parentElement != null)
			{
				DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
			}
		}

<#
			foreach(List<BaseShapeMap> mapList in shapeMaps.Values)
			{
				bool customParent = false;
				foreach(BaseShapeMap baseMap in mapList)
				{
					if(baseMap.HasCustomParentElement)
					{
						customParent = true;
						break;
					}
				}
				
				if(!customParent && mapList[0].ParentElementPath != null)
				{
					GeneratePathMethod(mapList[0].ParentElementPath, "GetParentFor"+mapList[0].Class.Name.Replace('@','_'));
#>

<#
				}
			}
			
			if(hasNonCustomConnector)
			{
#>
		private static DslModeling::ModelElement GetParentForRelationship(DslDiagrams::Diagram diagram, DslModeling::ElementLink elementLink)
		{
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = elementLink.LinkedElements;

			if (linkedElements.Count == 2)
			{
				DslDiagrams::ShapeElement sourceShape = linkedElements[0] as DslDiagrams::ShapeElement;
				DslDiagrams::ShapeElement targetShape = linkedElements[1] as DslDiagrams::ShapeElement;

				if(sourceShape == null)
				{
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[0]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
						if (shape != null && shape.Diagram == diagram)
						{
							sourceShape = shape;
							break;
						}
					}
				}
				
				if(targetShape == null)
				{
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[1]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
						if (shape != null && shape.Diagram == diagram)
						{
							targetShape = shape;
							break;
						}
					}
				}
				
				if(sourceShape == null || targetShape == null)
				{
					return null;
				}

				DslDiagrams::ShapeElement sourceParent = sourceShape.ParentShape;
				DslDiagrams::ShapeElement targetParent = targetShape.ParentShape;

				while (sourceParent != targetParent && sourceParent != null)
				{
					DslDiagrams::ShapeElement curParent = targetParent;
					while (sourceParent != curParent && curParent != null)
					{
						curParent = curParent.ParentShape;
					}

					if(sourceParent == curParent)
					{
						break;
					}
					else
					{
						sourceParent = sourceParent.ParentShape;
					}
				}

				while (sourceParent != null)
				{
					// ensure that the parent can parent connectors (i.e., a diagram or a swimlane).
					if(sourceParent is DslDiagrams::Diagram || sourceParent is DslDiagrams::SwimlaneShape)
					{
						break;
					}
					else
					{
						sourceParent = sourceParent.ParentShape;
					}
				}

				global::System.Diagnostics.Debug.Assert(sourceParent != null && sourceParent.ModelElement != null, "Unable to find common parent for view fixup.");
				return sourceParent.ModelElement;
			}

			return null;
		}
<#
			}
}
#>
	}
}