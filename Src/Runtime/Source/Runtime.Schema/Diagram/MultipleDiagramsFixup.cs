//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Microsoft.VisualStudio.Patterning.Runtime.Schema
{
	/// <summary>
	/// Rule that initiates view fixup when an element that has an associated shape is added to the model. 
	/// </summary>
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ElementSchema), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.CollectionSchema), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ExtensionPointSchema), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewSchema), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority + 1, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewHasElements), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ElementHasElements), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ElementHasExtensionPoints), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewHasExtensionPoints), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	internal sealed partial class FixUpMultipleDiagram : FixUpDiagramBase
	{
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		public override void ElementAdded(DslModeling::ElementAddedEventArgs e)
		{
			if(e == null) throw new global::System.ArgumentNullException("e");
		
			DslModeling::ModelElement childElement = e.ModelElement;
			if (this.SkipFixup(childElement))
				return;
			DslModeling::ModelElement parentElement;
			if(childElement is DslModeling::ElementLink)
			{
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::Diagram> diagrams =
					childElement.Store.ElementDirectory.FindElements<DslDiagrams::Diagram>();

				for (int i = 0; i < diagrams.Count; i++)
				{
					parentElement = GetParentForRelationship(diagrams[i], (DslModeling::ElementLink)childElement);

					if (parentElement != null)
					{
						DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
					}
				}

				return;
			} else
			if(childElement is global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ElementSchema)
			{
				// Method:
				// private Microsoft.VisualStudio.Modeling.ModelElement GetParentForElementSchema(ElementSchema childElement)
				// {
				// }
				// must be implemented in a partial class of Microsoft.VisualStudio.Patterning.Runtime.Schema.FixUpDiagram.  Given a child element,
				// this method should return the parent model element that is associated with the shape or diagram that will be the parent 
				// of the shape created for this child.  If no shape should be created, the method should return null.
				parentElement = GetParentForElementSchema((global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ElementSchema)childElement);
			} else
			if(childElement is global::Microsoft.VisualStudio.Patterning.Runtime.Schema.CollectionSchema)
			{
				// Method:
				// private Microsoft.VisualStudio.Modeling.ModelElement GetParentForCollectionSchema(CollectionSchema childElement)
				// {
				// }
				// must be implemented in a partial class of Microsoft.VisualStudio.Patterning.Runtime.Schema.FixUpDiagram.  Given a child element,
				// this method should return the parent model element that is associated with the shape or diagram that will be the parent 
				// of the shape created for this child.  If no shape should be created, the method should return null.
				parentElement = GetParentForCollectionSchema((global::Microsoft.VisualStudio.Patterning.Runtime.Schema.CollectionSchema)childElement);
			} else
			if(childElement is global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema)
			{
				parentElement = GetParentForPatternSchema((global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema)childElement);
			} else
			if(childElement is global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ExtensionPointSchema)
			{
				// Method:
				// private Microsoft.VisualStudio.Modeling.ModelElement GetParentForExtensionPointSchema(ExtensionPointSchema childElement)
				// {
				// }
				// must be implemented in a partial class of Microsoft.VisualStudio.Patterning.Runtime.Schema.FixUpDiagram.  Given a child element,
				// this method should return the parent model element that is associated with the shape or diagram that will be the parent 
				// of the shape created for this child.  If no shape should be created, the method should return null.
				parentElement = GetParentForExtensionPointSchema((global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ExtensionPointSchema)childElement);
			} else
			if(childElement is global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewSchema)
			{
				parentElement = GetParentForViewSchema((global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewSchema)childElement);
			} else
			{
				parentElement = null;
			}
			
			if(parentElement != null)
			{
				DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
			}
		}

		public static global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternModelSchema GetParentForPatternSchema( global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema root )
		{
			// Segments 0 and 1
			global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternModelSchema result = root.PatternModel;
			if ( result == null ) return null;
			return result;
		}

		public static global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema GetParentForViewSchema( global::Microsoft.VisualStudio.Patterning.Runtime.Schema.ViewSchema root )
		{
			// Segments 0 and 1
			global::Microsoft.VisualStudio.Patterning.Runtime.Schema.PatternSchema result = root.Pattern;
			if ( result == null ) return null;
			return result;
		}

		private static DslModeling::ModelElement GetParentForRelationship(DslDiagrams::Diagram diagram, DslModeling::ElementLink elementLink)
		{
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = elementLink.LinkedElements;

			if (linkedElements.Count == 2)
			{
				DslDiagrams::ShapeElement sourceShape = linkedElements[0] as DslDiagrams::ShapeElement;
				DslDiagrams::ShapeElement targetShape = linkedElements[1] as DslDiagrams::ShapeElement;

				if(sourceShape == null)
				{
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[0]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
						if (shape != null && shape.Diagram == diagram)
						{
							sourceShape = shape;
							break;
						}
					}
				}
				
				if(targetShape == null)
				{
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[1]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
						if (shape != null && shape.Diagram == diagram)
						{
							targetShape = shape;
							break;
						}
					}
				}
				
				if(sourceShape == null || targetShape == null)
				{
					return null;
				}

				DslDiagrams::ShapeElement sourceParent = sourceShape.ParentShape;
				DslDiagrams::ShapeElement targetParent = targetShape.ParentShape;

				while (sourceParent != targetParent && sourceParent != null)
				{
					DslDiagrams::ShapeElement curParent = targetParent;
					while (sourceParent != curParent && curParent != null)
					{
						curParent = curParent.ParentShape;
					}

					if(sourceParent == curParent)
					{
						break;
					}
					else
					{
						sourceParent = sourceParent.ParentShape;
					}
				}

				while (sourceParent != null)
				{
					// ensure that the parent can parent connectors (i.e., a diagram or a swimlane).
					if(sourceParent is DslDiagrams::Diagram || sourceParent is DslDiagrams::SwimlaneShape)
					{
						break;
					}
					else
					{
						sourceParent = sourceParent.ParentShape;
					}
				}

				global::System.Diagnostics.Debug.Assert(sourceParent != null && sourceParent.ModelElement != null, "Unable to find common parent for view fixup.");
				return sourceParent.ModelElement;
			}

			return null;
		}
	}
}