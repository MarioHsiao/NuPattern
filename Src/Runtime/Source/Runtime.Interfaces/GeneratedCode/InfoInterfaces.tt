<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\Runtime.Schema\DslDefinition.dsl'" #>
<#@ Include File="..\..\..\..\Common\Helpers\DslVersion.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\Helpers.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\PropertyChangedInterface.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq.Expressions;

namespace Microsoft.VisualStudio.Patterning.Runtime
{
<#
	foreach (var domainClass in this.DslLibrary.Classes)
	{
		GenerateInterface(domainClass);
	}

	foreach (var relation in this.DslLibrary.Relationships.Where(r => r.Properties.Count > 0))
	{
		if (!HasSkipAnnotation(relation.Notes))
		{
			GenerateInterface(relation, false);
		}
	}
#>
}
<#+

private void GenerateInterface(DomainClass domainClass, bool generatePropertyChanged = true)
{
#>
<#+
PushIndent("\t"); 

if (generatePropertyChanged)
{
	GeneratePropertyChanged(domainClass, ToInfo(domainClass));
}

var baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, string.Empty);
#>

/// <summary>
/// <#= domainClass.Description #>
/// </summary>
[Description("<#= domainClass.Description #>")]
[GeneratedCode("<#= this.ToolName #>", "<#= this.DslVersion #>")]
public partial interface I<#= ToInfo(domainClass) #> <#+ if(!string.IsNullOrEmpty(baseInterface)) { #>: I<#= ToInfo(baseInterface) #><#+ } #> 
{<#+
	if (string.IsNullOrEmpty(baseInterface) && !(domainClass is DomainRelationship))
	{
#>

	/// <summary>
	/// Gets the identifier of the element.
	/// </summary>
	[Description("Gets the identifier for this element.")]
	global::System.Guid Id { get; } <#+
	}

	foreach (var property in domainClass.Properties)
	{
		if (!HasSkipAnnotation(property.Notes))
		{
			GenerateProperty(property);
		}
	}
	
	foreach (var role in domainClass.RolesPlayed)
	{
		if (!HasSkipAnnotation(role.Notes))
		{
			GenerateProperty(role);
		}

		if (!role.IsMany && role.Relationship.Properties.Count > 0 && !HasSkipAnnotation(role.Relationship.Notes))
		{
			GenerateLinkProperty(role.Relationship);
		}
	}
#>
}

<#+	PopIndent(); #>
<#+
}

private void GenerateLinkProperty(DomainRelationship relationship)
{
	PushIndent("\t");
#>

/// <summary>
/// <#= relationship.Description #>
/// </summary>
[Description("<#= relationship.Description #>")]
I<#= ToInfo(relationship) #> <#= relationship.Name #> { get; }
<#+
	PopIndent();
}

private void GenerateProperty(DomainProperty property)
{
	if (!PropertyHasGetter(property))
		return;

	PushIndent("\t");
#>

/// <summary>
/// <#= property.Description #>
/// </summary>
[Description("<#= property.Description #>")]
<#= CodeGenerationUtilities.GetDomainTypeFullName(property) #> <#= property.Name #> { get; }
<#+
	PopIndent();
}

private bool PropertyHasGetter(DomainProperty property)
{
	if (property.GetterAccessModifier != AccessModifier.Public)
		return false;

	return true;
}

private void GenerateProperty(DomainRole role)
{
	if (!role.IsPropertyGenerator) 
	{
		return;
	}

	DomainRole opposite = role.Opposite;
	string castString = "";
	string propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	DomainRole typeRole = role;
	for (DomainRole current = role.BaseRole; current!=null; current = current.BaseRole)
	{
		if (current!= role && current.IsPropertyGenerator && current.PropertyName==role.PropertyName)
		{
			if ((current.Relationship.InheritanceModifier == InheritanceModifier.Abstract || role.Relationship.InheritanceModifier == InheritanceModifier.Abstract) && 
				current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
			{
				break;
			}
			else 
			{
				typeRole = current;
			}
		}
	}

	if (typeRole != role)
	{
		castString = "(" + propertyType + ")";
		propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
	}

	// Determine collection type for the property.
	string linkedElementCollectionType;
	if (typeRole.CollectionType != null)
	{
		// If a custom collection type was specified, use it.
		linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
	}
	else
	{
		switch (typeRole.Relationship.InheritanceModifier)
		{
			case InheritanceModifier.Abstract:
				linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
				break;
			case InheritanceModifier.None:
			case InheritanceModifier.Sealed:
				linkedElementCollectionType = "DslModeling::LinkedElementCollection";
				break;
			default:
				throw new NotSupportedException();
		}
	}
	PushIndent("\t");
#>

/// <summary>
/// <#= role.Description #>
/// </summary>
<#+
	if(role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
	{
#>
I<#= ToInfo(propertyType) #> <#= role.PropertyName #> { get; }
<#+
	}
	else
	{
#>
IEnumerable<I<#= ToInfo(propertyType) #>> <#= role.PropertyName #> { get; }
<#+
	}
	PopIndent();
}
#>