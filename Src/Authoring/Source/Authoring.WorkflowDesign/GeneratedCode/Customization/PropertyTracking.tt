<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\DslDefinition.dsl'" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#
	// ******************************************************************************************
	// This template generates the code required for implementing tracking properties in a DSL.
	// The code is an adaptation of the pattern found at: http://msdn.microsoft.com/en-us/library/cc825930.aspx
	//
	// Notes to DSL Implementors:
	// In order to implement a tracking property, you must do the following in additon to defining the property you want to track (for example, tracking the value of the: "MyProperty" property).
	// In the *.dsldefinition:
	//		For the tracked property ("MyProperty"), make it 'CustomStorage'.
	//		Add a new DomainProperty for the tracking state property in same class, called "IsMyPropertyTracking", of type Boolean, with a DefaultValue of "true".
	//			Make it Browsable 'false'
	//			Make both its "Setter" property "private", and "Getter" property "internal".
	//			Make its XMLSerialization representation "Ignore", so it is not ever persisted.
	// In Custom Code:
	//		Create the "public partial class" for the DomainClass containing the tracked property.
	//		Define a new method with signature: "private string CalculateMyPropertyValueTrackingValue()", and code the method to return the calculated text when the property is tracking.
	//	If you are using a custom TypeDescriptor for your class, call the method "ReplaceTrackingPropertyDescriptors" generated below in the GetProperties() method of your descriptor, 
	//  that replaces the property descriptors for the tracked property that allows the user to reset the property to being tracked."
	//
	// Finally, you must ensure there is a call to ResetTrackingProperties() in the SerializationHelper.LoadModel() and SerializationHelper.LoadModelAndDiagrams class for this DSL,
	// to ensure tracked properties are properly initialized when the model is loaded (deserialized). Without which the tracking is never disabled for updated properties.
	// ******************************************************************************************

	string dslName = this.DslLibrary.Name;

	// Find all domain properties that are named for tracking
	Dictionary<string, string[]> trackingClasses = new Dictionary<string, string[]>();
	foreach (var domainClass in this.DslLibrary.Classes)
	{
		List<string> trackedProperties = new List<string>();
		foreach (DomainProperty domainProperty in domainClass.Properties)
		{
            if ((domainProperty.Name.StartsWith("Is"))
                && (domainProperty.Name.EndsWith("Tracking")))
            {
                string trackedPropertyName = domainProperty.Name.Substring("Is".Length, (domainProperty.Name.Length - "Tracking".Length - 2));
				trackedProperties.Add(trackedPropertyName);
            }
		}

		if (trackedProperties.Count > 0)
		{
			trackingClasses.Add(domainClass.Name, trackedProperties.ToArray<string>());
		}
	}
#>
using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Design;
using NuPattern.Extensibility;

namespace <#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>
{
    /// <summary>
    /// Customizations for the <#= dslName #>SerializationHelper class.
    /// </summary>
	public partial class <#= dslName #>SerializationHelper
	{
		/// <summary>
		/// Resets all tracking properties.
		/// </summary>
		private static void ResetTrackingProperties(Store store)
		{
<#
			foreach (KeyValuePair<string, string[]> trackingClass in trackingClasses)
			{
#>
			// Two passes required - once to set all elements to storage-based
			// then another to set some back to being tracking.
			var <#= CodeGenerationUtilities.GetCamelCase(trackingClass.Key) #>s = store.ElementDirectory.AllElements.OfType<<#= trackingClass.Key #>>();
			foreach (var element in <#= CodeGenerationUtilities.GetCamelCase(trackingClass.Key) #>s)
			{
<# 
				foreach (string propertyName in trackingClass.Value)
				{
#>
				<#= trackingClass.Key #>.Is<#= propertyName #>TrackingPropertyHandler.Instance.PreResetValue(element);
<#
				}
#>
			}

			foreach (var element in <#= CodeGenerationUtilities.GetCamelCase(trackingClass.Key) #>s)
			{
<# 
				foreach (string propertyName in trackingClass.Value)
				{
#>
				<#= trackingClass.Key #>.Is<#= propertyName #>TrackingPropertyHandler.Instance.ResetValue(element);
<#
				}
#>
			}
<#
			}
#>
		}
	}

<#
	foreach (KeyValuePair<string, string[]> trackingClass in trackingClasses)
	{
#>
    /// <summary>
    /// Customizations for the <#= trackingClass.Key #> class.
    /// </summary>
    public partial class <#= trackingClass.Key #>
    {
<# 
		foreach (string propertyName in trackingClass.Value)
		{
#>
        private string <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Storage = string.Empty;
<#
		}
#>

        /// <summary>
        /// Replaces the property descriptors for the tracking property.
        /// </summary>
		/// <remarks>
		/// Returned descriptors allow the properties to be reset with tracked value and resume tracking once modified.
		/// </remarks>
		internal PropertyDescriptorCollection ReplaceTrackingPropertyDescriptors(PropertyDescriptorCollection properties)
		{
<# 
		foreach (string propertyName in trackingClass.Value)
		{
#>
			// Replace the existing descriptor for the <#= propertyName #> property
			DomainPropertyInfo <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Property = this.Store.DomainDataDirectory.GetDomainProperty(<#= trackingClass.Key #>.<#= propertyName #>DomainPropertyId);
			DomainPropertyInfo <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>TrackingProperty = this.Store.DomainDataDirectory.GetDomainProperty(<#= trackingClass.Key #>.Is<#= propertyName #>TrackingDomainPropertyId);
            var <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Descriptor = properties[Reflector<<#= trackingClass.Key #>>.GetProperty(e => e.<#= propertyName #>).Name];
			if (<#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Descriptor != null)
			{
				properties.Remove(<#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Descriptor);
				properties.Add(new TrackingPropertyDescriptor(this, <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Property, <#= CodeGenerationUtilities.GetCamelCase(propertyName) #>TrackingProperty, 
					<#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Descriptor.Attributes.Cast<Attribute>().ToArray<Attribute>()));
			}

<#
		}
#>
			return properties;
		}

<# 
		foreach (string propertyName in trackingClass.Value)
		{
#>
        /// <summary>
        /// Gets the <#= propertyName #> property value.
        /// </summary>
        private string Get<#= propertyName #>Value()
        {
            // Ensure we are not tracking
            if (this.Is<#= propertyName #>Tracking && !this.IsSerializing())
            {
				// *******************************************************************
				// Note to implementors:
				// You must provide this method, to return the calculated text when the property is tracked
				// Signature: 
				// public partial class <#= trackingClass.Key #>
				// {
				//		/// <summary>
				//		/// Returns the calculated value of the <#= propertyName #> property while being tracked.
				//		/// </summary>
				//		private string Calculate<#= propertyName #>TrackingValue()
				// }
				// *******************************************************************
                return this.Calculate<#= propertyName #>TrackingValue();
            }

            return this.<#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Storage;
        }
		
        /// <summary>
        /// Sets the <#= propertyName #> property value.
        /// </summary>
        private void Set<#= propertyName #>Value(string value)
        {
            // Ensure not de-serializing
            bool isSerializing = this.Store.TransactionManager.InTransaction && this.Store.TransactionManager.CurrentTransaction.IsSerializing;

            // Set value of property
            this.<#= CodeGenerationUtilities.GetCamelCase(propertyName) #>Storage = value;

            // Turn off tracking
            if (!this.Store.InUndoRedoOrRollback && !isSerializing)
            {
                this.Is<#= propertyName #>Tracking = false;
            }
        }

		/// <summary>
        /// Customizes the <#= propertyName #> property handler.
        /// </summary>
        internal partial class Is<#= propertyName #>TrackingPropertyHandler
        {
            /// <summary>
            /// Sets the value of the tracking property based on stored value of the <#= propertyName #> property.
            /// </summary>
            internal void ResetValue(<#= trackingClass.Key #> element)
            {
                string calculatedValue = null;

                try
                {
                    calculatedValue = element.Calculate<#= propertyName #>TrackingValue();
                }
                catch (NullReferenceException)
                {
                }
                catch (System.Exception e)
                {
                    if (ErrorHandler.IsCriticalException(e))
                    {
                        throw;
                    }
                }

                if (calculatedValue != null)
                {
                    if (string.Equals(element.<#= propertyName #>, calculatedValue, StringComparison.Ordinal)
                        || string.IsNullOrEmpty(element.<#= propertyName #>))
                    {
                        element.is<#= propertyName #>TrackingPropertyStorage = true;
                    }
                }
            }

            /// <summary>
            /// Preset the value of the tracking property as it is not serialized.
            /// </summary>
            internal void PreResetValue(<#= trackingClass.Key #> element)
            {
                // Force the tracking property to false so that the value
                // of the <#= propertyName #> property is retrieved from storage.
                element.is<#= propertyName #>TrackingPropertyStorage = false;
            }

            /// <summary>
            /// Called after the Is<#= propertyName #>Tracking property changes.
            /// </summary>
            protected override void OnValueChanged(<#= trackingClass.Key #> element, bool oldValue, bool newValue)
            {
                base.OnValueChanged(element, oldValue, newValue);
                if (!element.Store.InUndoRedoOrRollback && newValue)
                {
                    DomainPropertyInfo propInfo =
                        element.Store.DomainDataDirectory.GetDomainProperty(
                            <#= trackingClass.Key #>.<#= propertyName #>DomainPropertyId);
                    propInfo.NotifyValueChange(element);
                }
            }
        }

<#
		}
#>
	}

<#
	}
#>
}
