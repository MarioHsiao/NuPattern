<#@ Template Inherits="NuPattern.Library.ModelElementTextTransformation" HostSpecific="True"#>
<#@ ModelElement Type="NuPattern.Runtime.IProductElement" Processor="ModelElementProcessor" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="Microsoft.VisualStudio.TeamArchitect.PowerTools.dll" #>
<#@ Assembly Name="NuPattern.Runtime.Schema.dll" #>
<#@ Assembly Name="NuPattern.Runtime.Interfaces.dll" #>
<#@ Assembly Name="NuPattern.Authoring.Toolkit.Automation.dll" #>
<#@ Assembly Name="NuPattern.Extensibility.dll" #>
<#@ Assembly Name="System.ComponentModel.Composition" #>
<#@ Assembly Name="System.Data.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ Import Namespace="Microsoft.VisualStudio.Modeling" #>
<#@ Import Namespace="NuPattern.Runtime" #>
<#@ Import Namespace="NuPattern.Runtime.Schema" #>
<#@ Import Namespace="NuPattern.Extensibility" #>
<#@ Import Namespace="NuPattern.Authoring.Library" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.ComponentModel" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import Namespace="System.Data.Entity.Design.PluralizationServices" #>
<#@ Include File="Constants.t4" #>
<#@ Include File="Helpers.t4" #>
<#@ Include File="Header.t4" #>
<#@ Include File="ProductElementImplementation.t4" #>
<#
var library = this.Element.As<IPatternToolkitLibrary>();
var developmentView = this.Element.Parent.Parent.As<NuPattern.Authoring.PatternToolkit.IDevelopment>();
var toolkitInfo = developmentView.PatternToolkitInfo;

if (toolkitInfo == null)
    throw new Exception("ToolkitInfo element not found");

var patternModel = developmentView.PatternModel;
var pattern = LoadModel(patternModel.ToolkitDefinitionFile).Pattern;

var codegen = new ProductCodeGeneration<IPatternInfo, IProduct>(pattern);
codegen.AddType(typeof(Action));
codegen.AddType(typeof(System.ComponentModel.Composition.CreationPolicy));
codegen.EndInit();
#>
namespace <#=library.ToolkitProjectRootNamespace #>
{
<#GenerateUsings(codegen);#>

	<#GenerateToolkitCommentsAndAttributes(AttributeTargets.Class, library, toolkitInfo, pattern); #>
	internal partial class <#=pattern.CodeIdentifier #> : I<#=pattern.CodeIdentifier #>
	{
		private Runtime.IProduct target;
		private Runtime.IProductProxy<I<#=pattern.CodeIdentifier #>> proxy;

		/// <summary>
		/// For MEF.
		/// </summary>
		[ImportingConstructor]
		private <#=pattern.CodeIdentifier#>() { }

		/// <summary>
		/// Initializes a new instance of the <see cref="<#=pattern.CodeIdentifier #>"/> class.
		/// </summary>
		public <#=pattern.CodeIdentifier #>(Runtime.IProduct target)
		{
			this.target = target;
			this.proxy = target.ProxyFor<I<#=pattern.CodeIdentifier #>>();
			OnCreated();
		}	

		partial void OnCreated();
<#GenerateProperties(codegen, pattern);

PushIndent("\t");
PushIndent("\t");

foreach (var view in pattern.Views)
{
    this.WriteLine("");
    GenerateDescription(view);
#>
public virtual I<#=view.CodeIdentifier #> <#=view.CodeIdentifier #>
{ 
	get { return this.proxy.GetView(() => this.<#=view.CodeIdentifier #>, view => new <#=view.CodeIdentifier #>(view)); }
}
<#
}

PopIndent();
PopIndent();
#>

		/// <summary>
		/// Gets the generic <see cref="Runtime.IProduct"/> underlying element.
		/// </summary>
		public virtual Runtime.IProduct AsProduct()
		{
			return this.target;
		}

		/// <summary>
		/// Gets the generic underlying element as the given type if possible.
		/// </summary>
		public virtual TRuntimeInterface As<TRuntimeInterface>()
			where TRuntimeInterface : class
		{
			return this.target as TRuntimeInterface;
		}

		/// <summary>
		/// Deletes this instance.
		/// </summary>
		public virtual void Delete()
		{
			this.target.Delete();
		}
	}
}