<#+
    private IPatternModelInfo LoadPatternModel(string patternModelFile)
    {
        return (IPatternModelInfo)PatternModelSerializationHelper.LoadPatternModelFromFile(patternModelFile);
    }

    private void GenerateDeleteInterfaceMethod()
    {
#>

/// <summary>
/// Deletes this element.
/// </summary>
void Delete();
<#+
    }

    private void GenerateToolkitCommentsAndAttributes(AttributeTargets target, NuPattern.Authoring.PatternToolkitLibrary.IPatternToolkitLibrary library, NuPattern.Authoring.PatternToolkit.IPatternToolkitInfo toolkitInfo, INamedElementInfo element)
    {
        PushIndent("\t");
        GenerateComments(element);

        switch (target)
        {
            case AttributeTargets.Class:
#>
[ToolkitInterfaceProxy(ExtensionId ="<#=toolkitInfo.Identifier #>", DefinitionId = "<#=element.Id #>", ProxyType = typeof(<#=element.CodeIdentifier #>))]
<#+
                break;

            case AttributeTargets.Interface:
#>
[ToolkitInterface(ExtensionId ="<#=toolkitInfo.Identifier #>", DefinitionId = "<#=element.Id #>", ProxyType = typeof(<#=element.CodeIdentifier #>))]
<#+
                break;

            default:
                break;
        }
        GenerateCodeGenAttributes(library, target);
        GenerateCLSAttributes(element);
        PopIndent();
    }

    private void GenerateCodeGenAttributes(NuPattern.Authoring.PatternToolkitLibrary.IPatternToolkitLibrary library, AttributeTargets target)
    {
        var excludeFromCodeCoverage = library.ExcludeFromCodeCoverage;

        switch (target)
        {
            case AttributeTargets.Class:
#>
[System.CodeDom.Compiler.GeneratedCode("<#=libraryToolkitName#>", "<#=libraryToolkitVersion #>")]
<#+
                if (excludeFromCodeCoverage)
                {
#>
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
<#+
                }
                break;

            case AttributeTargets.Interface:
#>
[System.CodeDom.Compiler.GeneratedCode("<#=libraryToolkitName #>", "<#=libraryToolkitVersion #>")]
<#+
                break;
        }
    }

    private void GenerateComments(MemberInfo typeOrMember)
    {
        var description = typeOrMember.GetCustomAttributes(true).OfType<DescriptionAttribute>().Select(attr => attr.Description).FirstOrDefault();
        if (!string.IsNullOrEmpty(description))
        {
#>
/// <summary>
/// <#=description #>
/// </summary>
<#+
        }
        else
        {
#>
/// <summary>
/// The <#=typeOrMember.Name #>.
/// </summary>
<#+
         }
    }

    private void GenerateComments(INamedElementInfo element)
    {
        if (!string.IsNullOrEmpty(element.Description))
    {
#>
/// <summary>
/// <#=element.Description #>
/// </summary>
[Description("<#=element.Description #>")]
<#+
    }
    else
    {
#>
/// <summary>
/// <#=element.Description #>
/// </summary>
[Description("Description of <#=element.DisplayName #>")]
<#+
                                                                                                                                                                                                                                                                                                                                         }
     }

    private void GenerateUsings<TInfo, TRuntime>(ProductCodeGeneration<TInfo, TRuntime> codegen)
        where TInfo : IPatternElementInfo
        where TRuntime : IProductElement
    {
        GenerateUsings(codegen.SafeImports);
    }

    private void GenerateUsings<TInfo, TRuntime>(ViewCodeGeneration<TInfo, TRuntime> codegen)
        where TInfo : IViewInfo
        where TRuntime : IView
    {
        GenerateUsings(codegen.SafeImports);
    }

    private void GenerateUsings(IEnumerable<string> namespaces)
    {
        foreach (var ns in namespaces)
        {
#>
    using global::<#=ns #>;
<#+
        }
#>
    using Runtime = global::NuPattern.Runtime;
<#+
    }

    private void GenerateCLSAttributes(NuPattern.Runtime.INamedElementInfo element)
    {
        // Find all variable properties in the model
    var properties = element.GetProduct().GetAllProperties();

    var propertyTypes = properties.Select(prop => prop.Type)
        .Distinct<string>()
    .Select(type => Type.GetType(type, false, true))
    .Where(type => type != null);

            // Check if any property types are not CLS compliant.
        var isNotClsCompliant = propertyTypes
            .Any(type => !type.IsClsCompliant());

        if (isNotClsCompliant)
    {
#>
[CLSCompliant(false)]
<#+
    }
}
#>
