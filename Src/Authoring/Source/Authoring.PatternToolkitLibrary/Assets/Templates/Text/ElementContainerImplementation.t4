<#+
private void GenerateContainedElements(PluralizationService pluralizer, IElementInfoContainer infoElement)
{
	foreach (var element in infoElement.Elements)
	{
		GenerateContainedElementProperty(pluralizer, element, "GetElement", "GetElements");		
	}

	foreach (var extension in infoElement.ExtensionPoints)
	{
		GenerateContainedElementProperty(pluralizer, extension, "GetExtension", "GetExtensions");		
	}

	foreach (var element in infoElement.Elements)
	{
		GenerateContainedElementCreate(pluralizer, element);		
	}

	foreach (var element in infoElement.ExtensionPoints)
	{
		GenerateContainedExtensionCreate(pluralizer, element);		
	}
}

private void GenerateContainedElementCreate(PluralizationService pluralizer, IContainedElementInfo element)
{
	var name = Pluralize(pluralizer, element);
#>

/// <summary>
///	Creates a new <see cref="I<#=element.CodeIdentifier#>"/> <#+if (element.Cardinality == NuPattern.Runtime.Cardinality.OneToMany || element.Cardinality == NuPattern.Runtime.Cardinality.ZeroToMany) { #> and adds it to the <see cref="<#=name#>"/> collection, <#+}#> 
/// executing the optional <paramref name="initializer"/> if not <see langword="null"/>.
///	</summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public virtual I<#=element.CodeIdentifier#> Create<#=element.CodeIdentifier#>(string name, Action<I<#=element.CodeIdentifier#>> initializer = null, bool raiseInstantiateEvents = true)
{
<#+
	if (element is IElementInfo)
	{
#>
	return proxy.CreateElement<I<#=element.CodeIdentifier#>>(name, initializer, raiseInstantiateEvents);	
<#+
	}
	else if (element is ICollectionInfo)
	{
#>
	return proxy.CreateCollection<I<#=element.CodeIdentifier#>>(name, initializer, raiseInstantiateEvents);
<#+
	}
	else
	{
		throw new NotSupportedException("Unsupported element type");
	}
#>
}
<#+
}

private void GenerateContainedExtensionCreate(PluralizationService pluralizer, IContainedElementInfo element)
{
	var name = Pluralize(pluralizer, element);
#>

/// <summary>
///	Creates a new <see cref="I<#=element.CodeIdentifier#>"/> <#+if (element.Cardinality == NuPattern.Runtime.Cardinality.OneToMany || element.Cardinality == NuPattern.Runtime.Cardinality.ZeroToMany) { #> and adds it to the <see cref="<#=name#>"/> collection, <#+}#> 
/// executing the optional <paramref name="initializer"/> if not <see langword="null"/>.
///	</summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
public virtual I<#=element.CodeIdentifier#> Create<#=element.CodeIdentifier#>(string name, Guid productId, string toolkitId, Action<I<#=element.CodeIdentifier#>> initializer = null, bool raiseInstantiateEvents = true)
{
<#+
	if (element is IExtensionPointInfo)
	{
#>
	return proxy.CreateExtension<I<#=element.CodeIdentifier#>>(name, productId, toolkitId, initializer, raiseInstantiateEvents);	
<#+
	}
	else
	{
		throw new NotSupportedException("Unsupported element type");
	}
#>
}
<#+
}

private void GenerateContainedElementProperty(PluralizationService pluralizer, IContainedElementInfo element, string singularMethod, string pluralMethod)
{
	if (element.Cardinality == NuPattern.Runtime.Cardinality.ZeroToOne ||
		element.Cardinality == NuPattern.Runtime.Cardinality.OneToOne)
	{
#>

/// <summary>
/// Gets the <see cref="I<#=element.CodeIdentifier#>"/> contained in this element.
/// </summary>
public virtual I<#=element.CodeIdentifier#> <#=element.CodeIdentifier#> 
{ 
	get { return proxy.<#= singularMethod #>(() => this.<#=element.CodeIdentifier#>, element => new <#=element.CodeIdentifier#>(element)); }
}
<#+
	}
	else
	{
		var name = Pluralize(pluralizer, element);		
#>

/// <summary>
/// Gets all instances of <see cref="I<#=element.CodeIdentifier#>"/> contained in this element.
/// </summary>
public virtual IEnumerable<I<#=element.CodeIdentifier#>> <#=name#> 
{ 
	get { return proxy.<#= pluralMethod #>(() => this.<#=name#>, element => new <#=element.CodeIdentifier#>(element)); }
}
<#+
	}
}

private string Pluralize(PluralizationService pluralizer, IContainedElementInfo element)
{
	var name = pluralizer.IsSingular(element.CodeIdentifier) ? pluralizer.Pluralize(element.CodeIdentifier) : element.CodeIdentifier;
	if (name == element.Parent.CodeIdentifier)
		// Do not change if the pluralized version ends up being the same as the containing class.
		name = element.CodeIdentifier;

	return name;
}
#>
