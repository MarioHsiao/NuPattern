<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".gen.cs" #>
<#@ Dsl processor="DslDirectiveProcessor"  requires="fileName='..\..\DslDefinition.dsl'" #>
<#@ Include File="..\..\..\..\Common\Helpers\Helpers.tt" #>
<#@ Include File="..\..\..\..\Common\Helpers\PropertyChangedImplementation.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Globalization;
using System.Linq.Expressions;
using NuPattern.ComponentModel;
using NuPattern.Runtime;

<#
// We do generate the implementation for the binding classes too.
foreach (var domainClass in this.DslLibrary.Classes.Where(dc => !HasSkipAnnotation(dc.Notes)))
{
    GenerateInterface(domainClass);
}

#>
<#+
private void GenerateInterface(DomainClass domainClass)
{
    var annotations = GetAnnotations(domainClass.Notes);
    var typeIdentifier = annotations.ContainsKey("Interface") ?
        annotations["Interface"] : domainClass.Name;

#>

namespace <#=this.DslLibrary.Namespace #>
{ <#+
PushIndent("    ");

GeneratePropertyChanged(domainClass);

var baseInterface = "";
if (domainClass.BaseClass == null || this.DslLibrary.Classes.Contains(domainClass.BaseClass))
{
    baseInterface = CodeGenerationUtilities.GetBaseClass(domainClass, baseInterface);
}
#>

/// <summary>
/// <#=domainClass.Description #>
/// </summary>
[GeneratedCode("<#=this.ToolName #>", "<#=this.DslVersion #>")]
partial class <#=domainClass.Name #> : I<#=typeIdentifier #> 
{ <#+
foreach (var role in domainClass.RolesPlayed)
{
    GenerateProperty(domainClass, role);
}
#>
<#+
if (domainClass.BaseClass != null &&
    domainClass.BaseClass.Name == "ExtensionElement" &&
    domainClass.Notes.Equals("IsAutomationExtension=True", StringComparison.OrdinalIgnoreCase))
{
#>

    /// <summary>
    /// Gets the owner of this automation settings.
    /// </summary>
    public IPatternElementSchema Owner
    {
        get { return (IPatternElementSchema)((IAutomationSettingsSchema)this.Extends).Parent; }
    }

    /// <summary>
    /// Gets the name of this automation settings.
    /// </summary>
    public string Name
    {
        get { return ((INamedElementInfo)this.Extends).Name; }
    }

    /// <summary>
    /// Gets the name of this automation settings.
    /// </summary>
    public override string ToString()
    {
        return string.Format(CultureInfo.CurrentCulture, "({0})", this.GetType().Name);
    }
<#+
}
#>
}
<#+PopIndent(); #>
}
<#+
}

public Version DslVersion
{
    get { return new Version(this.DslLibrary.MajorVersion, this.DslLibrary.MinorVersion, this.DslLibrary.Build, this.DslLibrary.Revision); }
}

public string ToolName
{
    get { return "NuPattern"; }
}

private void GenerateProperty(DomainClass domainClass, DomainRole role)
{
    if (!role.IsPropertyGenerator)
    {
        return;
    }

    var opposite = role.Opposite;
    var castString = string.Empty;
    var annotations = GetAnnotations(opposite.RolePlayer.Notes);
    var propertyType = opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
    var propertyIdentifier = annotations.ContainsKey("Interface") ?
        annotations["Interface"] : propertyType;

    var classAnnotations = GetAnnotations(domainClass.Notes);
    var classIdentifier = classAnnotations.ContainsKey("Interface") ?
        classAnnotations["Interface"] : domainClass.Name;


    var typeRole = role;
    for (var current = role.BaseRole; current != null; current = current.BaseRole)
    {
        if (current != role && current.IsPropertyGenerator && current.PropertyName == role.PropertyName)
        {
            if ((current.Relationship.InheritanceModifier == InheritanceModifier.Abstract || role.Relationship.InheritanceModifier == InheritanceModifier.Abstract) &&
                current.Relationship.InheritanceModifier != role.Relationship.InheritanceModifier)
            {
                break;
            }
            else
            {
                typeRole = current;
            }
        }
    }

    if (typeRole != role)
    {
        castString = "(" + propertyType + ")";
        annotations = GetAnnotations(typeRole.Opposite.RolePlayer.Notes);
        propertyType = typeRole.Opposite.RolePlayer.GetRelativeName(role.RolePlayer.Namespace, true);
        propertyIdentifier = annotations.ContainsKey("Interface") ?
            annotations["Interface"] : propertyType;
    }

    // Determine collection type for the property.
    string linkedElementCollectionType;
    if (typeRole.CollectionType != null)
    {
        // If a custom collection type was specified, use it.
        linkedElementCollectionType = StripGenericSpecification(CodeGenerationUtilities.GetDomainTypeFullName(typeRole.CollectionType, role.RolePlayer.Namespace));
    }
    else
    {
        switch (typeRole.Relationship.InheritanceModifier)
        {
            case InheritanceModifier.Abstract:
                linkedElementCollectionType = "DslModeling::ReadOnlyLinkedElementCollection";
                break;
            case InheritanceModifier.None:
            case InheritanceModifier.Sealed:
                linkedElementCollectionType = "DslModeling::LinkedElementCollection";
                break;
            default:
                throw new NotSupportedException();
        }
    }

    PushIndent("    ");

    if (role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne)
    {
#>

/// <summary>
/// <#=role.Description #>
/// </summary>
I<#=propertyIdentifier #> I<#=classIdentifier#>.<#=role.PropertyName #>
{
    get { return this.<#=role.PropertyName #>; }
    set { this.<#=role.PropertyName #> = (<#=propertyType #>)value; }
}
<#+
}
    else
    {
#>

/// <summary>
/// <#=role.Description #>
/// </summary>
IEnumerable<I<#=propertyIdentifier #>> I<#=classIdentifier #>.<#=role.PropertyName #>
{
    get { return this.<#=role.PropertyName #>.Cast<I<#=propertyIdentifier #>>(); }
}

<#+
}

    // Generate Create factory methods.
    if (opposite.IsEmbedded)
    {
        if (opposite.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract)
        {
            ImplementCreate(propertyType, role.Opposite.PropertyName, propertyIdentifier);
        }

        foreach (var derived in opposite.RolePlayer.AllDescendants.Where(dc => dc.InheritanceModifier != InheritanceModifier.Abstract))
        {
            var derivedType = derived.GetRelativeName(derived.Namespace, true);
            ImplementCreate(derivedType, role.Opposite.PropertyName);
        }
    }

    PopIndent();
}

private void ImplementCreate(string propertyType, string propertyName, string propertyIdentifier = null)
{
    if (propertyIdentifier == null)
        propertyIdentifier = propertyType;
#>

/// <summary>
/// Creates an instance of a child <see cref="I<#=propertyIdentifier ?? propertyType#>"/>.
/// </summary>
public I<#=propertyIdentifier #> Create<#=propertyType#>()
{
    return this.Create<#=propertyType #>(null);
}

/// <summary>
/// Creates an instance of a child <see cref="I<#=propertyIdentifier#>"/> with an optional initializer to perform 
/// object initialization within the creation transaction.
/// </summary>
public I<#=propertyIdentifier #> Create<#=propertyType #>(Action<I<#=propertyIdentifier #>> initializer)
{
    var isSerializing = this.Store.TransactionManager.InTransaction && this.Store.TransactionManager.CurrentTransaction.IsSerializing;
    
    using (var tx = this.Store.TransactionManager.BeginTransaction("InnerTx", isSerializing))
    {
        var instance = this.Create<<#=propertyType #>>();
        instance.<#=propertyName #> = this;
        if (initializer != null)
        {
            initializer(instance);
        }

        tx.Commit();
        return instance;
    }
}
<#+
}
#>
